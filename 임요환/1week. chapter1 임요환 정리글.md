# 간략한 내용 정리

# 1 객체, 설계
## 이 책의 목적
- 객체지향 패러다임이 제시하는 프로그래밍 패러다임을 설명하는 것
- 객체지향 패러다임이라는 용어를 말할 때 완벽하게 동일하진 않지만 어느 정도 유사한 그림을 그릴 수 있는 기반을 제공할 것
- 객체지향에 대한 오해를 제거함으로써 객체지향 프로그래밍을 하는 개발자들이 동일한 규칙과 표준에 따라 프로그램을 작성할 수 있게 할 것

## 1-1 객체, 설계
- 소프트웨어 분야는 아직까지는 이론보다 실무가 더 중요함
- 설계에 관해 설명할 때 가장 유용한 도구는 개념과 용어가 아닌 `코드` 그 자체임

## 1-2 무엇이 문제인가

### 소프트웨어 모듈이 가져야하는 세 가지 기능
1. 모든 모듈은 제대로 실행되어야함
2. 변경이 용이해야함
3. 이해하기 쉬워야함

### 예상을 빗나가는 코드
- 이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드
- Audience와 TicketSeller는 Theater의 통제를 받는 수동적인 존재가 되어 Theater의 enter() 메시지를 이해하기 위해서는 여러가지 세부적인 내용들을 기억하고 있어야함
- Audience와 TicketSeller가 변경될 경우 Theater도 변경되어야 하므로 변경에 용이하지 않음

### 변경에 취약한 코드
- Theater에 너무 많은 `의존성(dependency)`이 생성되어 있음
- 의존성은 변경에 대한 영향을 암시함 -> 어떤 객체가 변경될 시 의존하는 다른 객체도 함께 변경될 수 있음
- 의존성을 완전히 없애는 것이 정답은 아니며 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거해야함
- 객체 사이의 의존성이 과한 경우를 가리켜 `결합도(coupling)`가 높다고 말함
- 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야 함

## 1-3 설계 개선하기
- Audience와 TicketSeller를 `자율적인 존재`로 만들어야함

### 자율성을 높이자
- `캡슐화(encapsulation)` = 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
- 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것
- 캡슐화를 통해 객체 내부로의 접근을 제한하여 객체와 객체 사이의 결합도를 낮춤
- Theater는 TicketSeller의 `인터페이스(interface)`에만 의존하고 TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 `구현(implementation)`의 영역에 속함

### 캡슐화와 응집도
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 `응집도(cohesion)`이 높다고 말함
- 자율적인 객체는 결합도를 낮추며 응집도를 높임
- 자율적인 객체는 자신의 데이터는 자기가 책임져야함

### 절차지향과 객체지향
- 절차지향 프로그래밍(Procedural Programming)
  - 메서드 = 프로세스(Process)
  - Audience, TicketSeller, Bag, TicketOffice = 데이터(Data)
  - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
  - 예상을 하기 어려우며 코드를 읽는 사람과 원할한 소통을 할 수 없음
  - 데이터 변경으로 인한 영향을 지역적으로 고립시키기가 힘듬
- 객체지향 프로그래밍(Object-Oriented Programming)
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
  - 의존성이 적절히 통제되고 하나의 변경으로 인한 여파가 다른 클래스로 전파되는 것을 효율적으로 억제함
 
### 책임의 이동(shift of responsibility)
- 절차지향과 객체지향의 근본적인 차이를 만들어냄
- 절차지향 방식은 Theater에 책임이 너무 집중되어 있음
- 객체지향 바식으로 Theater의 책음을 각각의 객체들에게 적절하게 이동시키며 각 객체들이 자신을 스스로 책임지는 자율적인 객체가 되게함
- 설계를 어렵게 만드는 것은 `의존성`이며 불필요한 의존성을 제거하여 `결합도`를 낮추며 결합도를 낮추기 위해 `캡슐화`를 사용하였고 캡슐화를 통해 `자율성`과 `응집도`가 높은 객체들의 공동체를 창조할 수 있음

### 더 개선할 수 있다
- 어떤 기능을 설계하는 방법은 한가지 이상일 수 있음
- 동일한 기능을 한가지 이상의 방법으로 설계할 수 있기 때문에 설계는 트레이드오프의 산물임
- 설계는 균형의 예술이며 훌륭한 설계는 적절한 트레이드오프의 결과물임
- Audience에 대한 결합도 vs TicketOffice의 자율성

### 그래, 거짓말이다!
- 객체지향의 세계에서는 수동적인 존재도 능동적이고 자율적인 존재로 바뀜 -> `의인화(anthropomorphism)`

## 1-4 객체지향 설계

### 설계가 왜 필요한가
- 설계 = 코드를 배치하는 것
- 좋은 설계 = 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계
- 요구사항 변경은 코드의 수정을 초래하고 코드의 수정은 버그를 발생할 가능성이 높으며 버그는 코드를 수정하려는 의지를 꺽음

### 객체지향 설계
- 객체지향 설계는 코드 변경이라는 측면에서 다른 방법들보다 안정감을 줌
- 메시지를 전송하기 위해 두 객체를 결합시키고 객체 사이의 의존성을 만듬
- 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계임

# 읽고 느낀 점
- 직접 코드로 객체들 간의 의존성을 최소화 하며 자율적인 객체로 만드는 과정을 보게되어 매우 도움이 되었다.
- 좋은 설계에 대한 방향성을 확실히 잡아가는것 같았다.
