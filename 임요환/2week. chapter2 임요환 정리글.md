# 간략한 내용 정리

# 2 객체지향 프로그래밍

## 2-1 영화 예매 시스템
### 요구사항 살펴보기
- 할인 조건과 할인 정책 구현

## 2-2 객체지향 프로그래밍을 향해
### 협력, 객체, 클래스
- 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞춰야함
- 객체들이 어떤 상태와 행동을 가지는지 먼저 결정해야함
- 객체를 독립적인 존재가 아니라 협력하는 공동체의 일원으로 바라보는 것이 설계를 유연하고 확장가능하게 만듬

### 도메인 구조를 따르는 프로그램
- 도메인 = 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 클래스의 이름은 대응되는 도메인의 개념의 이름과 동일하거나 유사하게 지어야 함(영화 = Movie, 상영 = Screening 등)

### 클래스 구현하기
- 인스턴스 변수의 가시성은 private, 메서드의 가시성은 public
- 클래스의 경계를 구분짓는 것이 중요함 -> 경계의 명확성이 객체의 자율성을 보장하기 때문, 프로그래머에게 구현의 자유를 제공하기 때문
- 내부(감출 부분), 외부(공개할 부분)
- 외부에서는 객체의 속성에 직접 접근할 수 없고 public 메서드만을 통해 내부 상태를 변경할 수 있게 함

### 자율적인 객체
- 객체는 상태(state)와 행동(behavior)을 함께하는 복합적인 존재이며 스스로 판단하고 행동하는 자율적인 존재임
- 캡슐화 = 데이터와 기능을 객체 내부로 함께 묶는 것
- 접근 제어(access control)를 위해 접근 수정자(access modifier)를 제공함(private, public, protected, default)
- 퍼블릭 인터페이스(public interface) = 외부에서 접근 가능한 부분
- 구현(implementation) = 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분

### 프로그래머의 자유
- 클래스 작성자(class creator) = 새로운 데이터 타입을 프로그램에 추가
- 클라이언트 프로그래머(client programmer) = 클래스 작성자가 추가한 데이터 타입을 사용
- 구현 은닉(implementation hiding) = 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 낸부 구현을 마음대로 변경할 수 있음

### 협력하는 객체들의 공동체
- Long 타입은 변수의 크기나 연산자의 종류와 관련된 구현 관점의 제약은 표현할 수 있지만 Money 타입처럼 저장하는 값이 금액과 관련돼 있다는 의미를 전달할 수 없음
- 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 없음
- 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것임
- 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높임

### 협력에 관한 짧은 이야기
- 다른 객체 인터페이스에 공개된 행동을 수행하도록 요청(request) = 메시지를 전송(send a message) -> 메시지를 수신(receive a message) -> 자신만의 방법 메서드(method)를 이용하여 수신된 메시지 처리 = 자율적인 방법에 따라 요청을 처리한 후 응답(response)
- 메시지와 메서드의 구분이 다형성(polymorphism)의 개념이 출발함

## 2-3 할인 요금 구하기
### 할인 요금 계산을 위한 협력 시작하기
- 상속, 다형성, 추상화

### 할인 정책과 할인 조건
- 추상 클래스(abstract class) = 코드가 유사한 두 클래스 사이의 중복 코드를 제거하기 위해 공통 코드를 보관할 장소
- 오버라이딩(overriding) = 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우
- 오버로딩(overloading) = 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다름

## 2-4 상속과 다형성
### 컴파일 시간과 실행 시간 의존성
- 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있음
- 클래스에서는 DiscountPolicy에 의존하지만 실제로 객체는 DiscountPolicy에 구현되는 AmountDiscountPolicy 혹은 PercentDiscountPolicy에 의존하게 됨
- 코드의 의존성과 실행 시점의 의존성이 다르면 코드를 이해하기 어려워지지만 코드는 더 유연해지고 확장 가능해짐 = 트레이드오프 발생

### 차이에 의한 프로그래밍
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
- 상속은 코드를 재사용하기 위해 널리 사용하는 방법임

### 상속과 인터페이스
- 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에 부모클래스가 나오는 모든 장소에서 자식 클래스를 사용할 수 있음(리즈코프 치환 원칙, 업캐스팅)

### 다형성
- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라짐
- 다형성은 컴파일 시점이 아닌 실행 시점에 실행될 메서드가 결정됨 -> 지연 바인딩(lazy binding), 동적 바인딩(dynamic binding)
- 전통적인 함수 호출처럼 컴파일 시점에 결전됨 -> 초기 바인딩(early binding), 정적 바인딩(static binding)

### 구현 상속과 인터페이스 상속
- 구현 상속(implementation inheritance) = 서브클래싱(subclassing) = 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용한 것
- 인터페이스 상속(interface inheritance) = 서브타이핑(subtyping) = 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것
- 상속은 구현상속이 아니라 인터페이스 상속을 사용해야함
- 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높음

## 2-5 추상화와 유연성
### 추상화의 힘
- 요구사항의 정책을 높은 수준에서 서술할 수 있음
- 설계가 좀 더 유연해짐
- 재사용 가능한 설계의 기본을 다루는 디자인 패턴(design pattern)이나 프레임워크(framework) 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용함

### 유연한 설계
- 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택해라 -> if(discountPolicy == null) 보다는 NoneDiscountPolicy 객체를 하나 더 만들자

### 추상클래스와 인터페이스의 트레이드오프
- 이상적으로는 인터페이스를 사용한 설계가 더 좋아보이지만 비용이 너무 과하다고 생각할 수 있고 기존 클래스 역시 할인 금액이 0원이라는 사실을 효과적으로 전달하기 떄문에 어떤 설계가 더 나은지는 확신할 수 없다 = 트레이드오프

### 코드 재사용
- 합성(composition) = 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
- AmountDiscountMovie, PercentDiscountMovie 클래스를 만드는 대신 Movie 클래스에 DiscountPolicy를 받는 법

### 상속
- 상속은 캡슐화를 위반함 -> 부모 클래스의 내부 구조를 잘알고 있어야 함, 부모 클래스의 구현이 자식 클래스에게 노출됨, 자식 클래스가 부모 클래스와 강결합 하게 됨 -> 부모클래스 변경시 자식클래스도 함께 변경될 확률이 높음
- 설계를 유연하지 못하게 함 -> 컴파일 시점에서 관계를 결정하게 됨 -> 실행 시점에서 객체의 종류를 변경하는 것이 불가능

### 합성
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
- 상속의 두가지 문제점을 해결함
    - 구현을 효과적으로 캡슐화 할 수 있음
    - 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만듬
- 대부분의 설계에서 상속과 합성은 함께 사용됨
- 코드를 재사용하는 경우에는 상속보다 합성을 선호함
- 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용함

# 읽고 느낀 점
- 돈이라는 것을 단순히 숫자(int, long, BigDemical)로만 나타내지 않고 하나의 Money라는 도메인으로 의미있게 활용할 수 있다는 것에 대해 새롭게 다가왔다
- 옛날에 내가 봤다면 이거 좀 억지아니야 라는 생각을 받을 수도 있겠지만 객체지향의 세계에서는 이렇게 설계하는 것이 더 유연성을 높일 수 있다
- 상속과 인터페이스를 예제를 통해 좀더 명확하게 알게되었으며 컴파일 시간과 실행 시간의 의존성과 다형성의 관계에 대해서도 배울 수 있었다
- 컴파일 시간과 실행 시간의 의존성은 메소드 디스패치와 관련되어 있지않나 생각해보았다 (https://limyohwan.tistory.com/38)
- 합성이 왜 사용하게 되었는지에 대해 명확하게 알게되었던것 같다
- 단순히 필드에 해당 객체를 포함하는 것이라고만 생각했는데 AmountDiscountMovie, PercentDiscountMovie 예제를 보면서 이래서 합성을 사용하는 거구나라고 확실히 느꼈던것 같다
- 공부를 하면 할 수록 부족한 부분이 너무 많다고 느껴진다

# 의문, 고민, 같이 이야기하고 싶은 부분
- 1장과 2장에서 유독 트레이드오프라는 단어가 많이 나오는 것 같다.
- 트레이드오프의 간격을 줄일 최고의 방법은 무엇이라고 생각들 하시나요?