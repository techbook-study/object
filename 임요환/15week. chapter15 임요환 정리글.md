# 간략한 내용 정리

# 15 디자인 패턴과 프레임워크
- 디자인 패턴
    - 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법
    - 설계를 재사용함
    - 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공
    - 협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음
- 프레임워크
    - 설계와 코드를 함께 재사용하기 위한 것
    - 견고한 구현 코드를 쉽고 빠르게 재사용 가능
    - 특정한 변경을 일관성있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공
    - 일관성 있는 협력을 제공하는 확장 가능한 코드
- 두개 모두 협력을 일관성 있게 만들기 위한 방법

## 15-1 디자인 패턴과 설계 재사용
### 소프트웨어 패턴
- 패턴의 특징
    - 반복적으로 발생하는 문제와 해법의 쌍으로 정의됨
    - 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며 이 지식을 다른 사람과 의사소통할 수 있음
    - 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 도움
    - 패턴의 요점은 패턴이 실무에서 탄생했다는 점임
- 패턴의 정의
    - 하나의 실무 컨텍스트(practical context)에서 유용하게 사용해 왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어(idea)
    - 패턴은 발명했다고 하지 않고 발견했다고 말함
- 패턴의 가치
    - 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있음
    - 패턴은 경험의 산물임
- 패턴 언어(Pattern Language), 패턴 시스템(Pattern System) = 연관퇸 패턴들의 집합들이 모여 구성됨

### 패턴 분류
- 패턴의 범위나 적용 단계에 따라 아키텍처 패턴(Architecture Pattern), 분석 패턴(Analysis Pattern), 디자인 패턴(Design Pattern), 이디엄(Idiom)의 4가지로 분류함
- 디자인 패턴 = 특정 정황 내에서 일반적인 설계문제를 해결하며 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술함
- 아키텍처 패턴 = 미리 정의된 서브시스템들을 제공하고 각 서브시스템들의 책임을 정의하며 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함함
- 이디엄 = 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로 주어진 언어의 기능을 사용해 컴포넌트 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술함
- (상위) 아키텍처 패턴 > 디자인 패턴 > 이디엄 (하위)
- 분석 패턴 = 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춤

### 패턴과 책임-주도 설계
- STRATEGY 패턴 = 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공
- BRIDGE 패턴 = 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만듬
- OBSERVER 패턴 = 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공함
- COMPOSITE 패턴 = 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있음
- 패턴을 따르면 특정 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있음
- 구현 코드가 디자인 패턴을 따른다는 것은 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아님 -> 여러가지 구현 방법이 존재할 수 있음

### 캡슐화와 디자인 패턴
- STRATEGY 패턴 = 알고리즘의 변경을 캡슐화화를 위해 객체 합성을 이용함, 복잡도 높음, 결합도 낮음, 런타임에 변경 가능
- TEMPLATE METHOD 패턴 = 알고리즘을 캡슐화하기 위해 합성 관계가 아닌 상속 관계를 사용하는 것, 복잡도 낮음, 결합도 높음, 런타임에 변경 불가
- DECORATOR 패턴 = 객체의 행동을 동적으로 추가할 수 잇게 해주느 패턴으로 객체 행동을 결합하기 위해 객체 합성을 사용함, 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화함
- 디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것임
- 디자인 패턴의 구현 방법이나 구조 대신 어떤 변경을 캡슐화하는지를 이해하는 것이 중요함 -> 더 나아가 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요함

### 패턴은 출발점이다
- 패턴은 설계의 목표가 되어서는 안됨(목적지) -> 패턴은 출발점임
- 패턴을 사용하며 부딪히는 대부분의 문제는 패턴을 맹목적으로 사용할 때 발생함 -> 목적에 맞게 패턴을 수정하라
- 패턴을 잘 알지 못하는 사람이 패턴을 적용하게 되면 불필요하게 복잡한 설계를 만들 수 있음
- 패턴을 가장 효과적으로 정요하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것임

## 15-2 프레임워크와 코드 재사용
### 코드 재사용 대 설계 재사용
- 디자인 패턴은 설계를 프로그래밍 언어의 특성에 맞춰 가공하고 구현 코드를 재작성해야 함
- 설계 재사용과 코드 재사용을 적절히 조합하는 것이 가장 이상적인 재사용 형태임
- 프레임워크
    - 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계 = 구조적인 측면
    - 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격(skeleton) = 코드와 설계의 재상요이라는 사용 목적의 측면

### 상위 정책과 하위 정책으로 패키지 분리하기
- 추상 클래스와 인터페이스 같은 추상화를 사용하여 일관성 있는 협력을 구성
- 상위 정책은 세부 사항보다 더 다양한 상황에서 재사용될 수 있어야 함
- 상위 정책이 세부 사항에 의존하게 되면 상위 정책이 필요한 모든 경우에 세부 사항도 항상 함께 존재해야 하기 때문에 상위 정책의 사용성이 낮아짐 -> 의존성 역전 원칙에 맞게 상위 정채고가 세부 사항 모두 추상화에 의존하게 만듬
- 변하지 않는 것 = 상위 정책에 속하는 역할들의 협력 구조
- 변하는 것 = 구체적인 세부 사항
- 변하는 것과 변하지 않는 것을 서로 다른 주기로 배포할 수 있도록 별도의 배포 단위로 분리해야 함
- 변하는 것과 변하지 안흔 것을 별도의 패키지로 분리함
- 세부 사항 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 함
- 프레임워크는 여러 애플리케이션에 걸쳐 일관성 있는 협력을 구현할 수 있게 해줌

### 제어 역전 원리
- 상위 정책 재새용 = 핵심 개념들 사이의 협력 관계 재사용
- 객체지향 설계는 의존성이 역전된 설계임
- 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이며 의존성 방향 뿐만 아니라 제어 흐름의 주체 역시 역전시킴
- 전통적인 구조에서는 상위 정책의 코드가 하부의 구체적인 코드를 호출하지만 의존성 역전 구조에서는 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출함
- 제어 역전 원리(Inversion of Conversion), 할리우드(Hollywood) 원리 = 의존성을 역전시키면 제어 흐름의 주체 역시 역전됨
- 프레임워크는 해결책만 제공하고 애플리케이션에 따라 달라지는 특정 동작은 비워둠 -> 이렇게 완성되지 않은 채로 남겨진 동작을 훅(hook)이라고 부름
- 프레임워크가 적절하게 실행할 코드를 작성하고 프레임워크가 그 코드를 호출할 때 까지 기다림 -> 제어가 프레임워크로 넘어감(할리우드에서 캐스팅 담장자가 "먼저 연락하지마세요 저희가 연락드리겠습니다" 라고 말하는 것과 같음)

# 읽고 느낀 점
- 디자인 패턴에 대해 공부를 할 때 대충 그 패턴을 사용하는 방법에 대해 숙지하기 위해서만 노력했던거 같다
- 하지만 책에서 중요한 핵심 부분을 디자인 패턴을 구현하는 것보다 어떤 부분을 캡슐화 하는지 더 나아가 캡슐화를 하기위해 어떤 방법을 사용하는지에 대하여 더 중점적으로 디자인 패턴을 공부하는게 나은 방향인 것 같다
- 의존성 역전 원리와 제어 역전 원리에 대해 다시 한번 복습하는 부분이 되었다
- 프레임워크를 설계하기 위해서는 의존성 역전 원리(상위 정책이 하위 정책에 의존하지 않고 추상화에 의존)를 따르며 프레임워크 내의 코드는 내가 호출하는게 아닌 프레임워크가 호출해줄 떄까지 기다려야함(의존성 역전)에 대해 개념을 이해하게 되었다