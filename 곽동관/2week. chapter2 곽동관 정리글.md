## 요약 정리

### 협력, 객체, 클래스
- 클래스 기반의 객체지향 언어에 익숙한 사람이라면 가장 먼저 어떤 클래스(class)가 필요한지 고민한다.
- 이것은 **객체지향의 본질과 거리가 멀다**
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체 일원으로 봐야한다.
	- 객체는 홀로 존재하는 것이아니다.
	- 객체를 협력하는 공동체의 일원으로 바라보는 것은 **설계를 유연하고 확장 가능하게 만든다.**

### 도메인(domain)
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

### 클래스의 내부와 외부를 구분해야 하는 이유
- 경계의 명확성이 객체의 자율성을 보장하기 때문
- 프로그래머에게 구현의 자유를 제공하기 때문

### 자율적인 객체
- 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재
- 객체는 스스로 판단하고 행동하는 자율적인 존재
- 데이터와 기능을 객체 내부로 함께 묶는 것을 **캡슐화** 라고 한다.
- 외부에서 접근을 통제하기위해 접근 제어(access control)메커니증 제공
	- public, protected, private 와 같은 접근 수정자(access modifier) 제공
- 객체는 상태는 숨기고 행동만 외부에 공개해야한다.
	- public이나 private라는 키워드를 제공하면 private로 선언해서 감추고 외부에 제공해야하는 일부 메서드만 public으로 제공한다.

객체들 사이에 이뤄지는 상호작용을 협력(collaboration)이라고 부른다.

### 협력
- 객체는 다른 객체의 인터페이스 공개된 행동을 수행하도록 요청(request) 할수 있다.
- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response) 한다.
- 객체가 다른 객체와 상호작용 할 수 있는 유일한 방법은 메시지를 전송 하는 것 뿐
- 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(Method)** 라고 한다.
- 메시지와 메서드의 구분에서 부터 다형성(polymorphism)의 개념이 출발한다.

### 객체지향에서 중요한 두 가지 개념
- 상속(inheritance)
- 다형성
- 이 기반에는 추상화(abstraction)의 원리가 숨어있다.

### 오버라이딩과 오버로딩
- 오버라이딩(overriding) 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의 하는 경우
- 오버 로딩(overloading) 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다.

### 객체지향의 설계가 가지는 특징
- 코드의 의존성과 실행 시점의 의존성이 다르다. == 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
-  **간과 하면 안되는 사실** 코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 코드를 이해하기 어려워 진다.

### 상속
- 상속이 가치 있는 이유
	- 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려 받을 수 있기 때문
- 자식 클래스가 부모 클래스를 대신 하는 것을 업캐스팅(upcasting)이라고 부른다.

### 바인딩
- 메시지와 메서드를 실행 시점에 바인딩 하는 것
	- 지연 바인딩(lazy binding)
	- 동적 바인딩(dynamic binding)
- 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것
	- 초기 바인딩(early binding)
	- 정적 바인딩(static binding)

### 구형 상속과 인터페이스 상속
- 구현 상속(implemetation inheritance) - 코드를 재사용 하기 위한 목적
	- 서브 클래싱(subclassing)
- 인터페이스 상속(interface inheritance) - 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용
	- 서브타이핑(subtyping)

### 합성
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
- 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.
- 다형성을 위해 인터페이스를 재사용 하는 경우에는 상속과 합성을 함게 조합해서 사용해야 한다.


## 읽고 느낀점
자율적인 객체를 만들기 위해선 어떻게 해야하나 라는 생각을 많이 했었는데 접근제어자 or 캡슐화를 통해 클래스의 내부와 외부를 구분하여 사용 함으로써 자율적인 객체를 만든다는 것을 알았다.
또한, 실행시점 or 컴파일 시점에 의존성이 생긴다는게 이런 관점으로 생각을 안하다보니까 많이 생소하게 다가왔다 블로그에 정리가 필요해 보인다.