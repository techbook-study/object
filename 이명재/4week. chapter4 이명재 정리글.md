# 설계 품질과 트레이드오프

## 00. 객체지향 설계
### 객체지향 설계 포인트
- 책임 주도 설계
  - 책임이 객체지향 애플리케이션 전체의 품질을 결정
- 객체지향 설계의 관점
  - 객체지향 설계의 핵심은 책임
  - 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다는 것
- 설계
  - 설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생
  - 좋은 설계 -> 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것.
    - 적절한 비용으로 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성
- 결합도와 응집도 합리적인 소비를 위한 원칙
  - 객체의 상태가 아니라 객체의 행동에 초첨을 맞춤
  - 객체를 단순한 데이터의 집합으로 바라보면 설계 변경에 취약
  - 책임에 초점을 맞춤
- 책임
  - 객체의 상태에서 행동
  - 객체와 객체 사이의 상호작용으로 설계 중심으로 이동
  - 결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화 하는 개체들을 창조할 수 있는 기반을 제공

## 01. 데이터 중심의 영화 예매 시스템
### 시스템을 객체로 분할 방법
- 상태를 분할의 중심축으로 삼는 방법
  - 인터페이스의 변경을 초래
- 책임을 분할의 중심축으로 삼는 방법
  - 인터페이스에 속하고 상태를 캡슐화 함
### 데이터를 준비하자
- 데이터 중심의 설계 -> 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법
  - 객체가 내부에 저장해야 하는 데이터가 무엇인가
- Moive 클래스
  - 객체의 종류를 저장하는 인스턴스 변수와 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수를 하나의 클래스 안에 함께 포함
- 캡슐화
  - 내부의 데이터를 반환하는 접근자와 데이터는 변경하는 수정자를 추가
- DiscountCondition 클래스
  - 할인 조건의 타입을 저장할 인스턴스 변수 type 포함
    - movieType에서 순번조건 -> 상영 순번, 기간 조건 -> 요일,시작 시간, 종료시간 포함
- Screening 클래스 구현
- Reservation 클래스 구현
- Customer 클래스 구현
- ReservationAgency 클래스 구현
  - reserve 메서드 구분
    - DiscountCondition에 대해 루프를 돌면서 할인 가능 여부 확인하는 for문
      - 영화의 할인 여부를 판단 -> 기간 조건, 순번 조건
    - discountable 변수의 값을 체크하고 적절한 할인 정책에 따라 예매 요금을 계산하는 if문

## 02. 설계 트레이드오프
### 캡슐화
- 객체의 내부 구현을 외부로 부터 감추기 위함
- 구현과 인터페이스를 분리하고 외부에서는 인터페이스만 의존하도록 관계를 조절
- 설계가 필요한 이유는 요구사항이 변경되기 떄문이고, 캡슐화가 설계의 품질의 기준임
- 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제 할 수 있음
- 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
- 유지보수성이 목표 -> 코드 변경에 용이
### 응집도
- 모듈에 포함된 내부 요소들이 연관돼 있는 정도
- 객체,클래스에 관련 높은 책임들 할당했는지, 하나의 목적에 협력하는지
### 결합도
- 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지 나타내는 척도
- 객체,클래스가 협력에 필요한 적절한 수준의 관계만 유지 하는지, 각 모듈에 대해 필요한 것만 알고 있는지
### 좋은 설계
- **오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계**
- 높은 응집도와 낮은 결합도를 추구함
- 클래스의 구현이 아닌 인터페이스에 의존하도록 코드 작성
- 퍼블릭 인터페이스를 수정했을 떄만 다른 모듈에 영향을 미치는 경우
- 결합도가 높아도 상관없는 경우 -> 라이브러리,프레임워크 등 변경 확률이 낮은 것 (ex.String, ArrayList)

## 03. 데이터 중심의 영화 예매 시스템의 문제점
### 캡슐화 위반
- Movie 클래스
 - getFee,setFee는 Money 타입의 fee라는 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러냄
 - 추측에 의한 설계 전략 -> 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 됨 -> 내부 구현이 퍼블릭 인터페이스에 그대로 노출
### 높은 결합도
- ReservationAgency 클래스
  - 한명의 요금을 계산하기 위해 Movie의 getFee를 호출하며 계산된 결괴를 Money 타입의 fee에 저장함
  - fee의 타입을 변경 -> getFee 반환 타입 수정, getFee 메서드를 호출하는 ReservationAgency의 구현도 변경된 타입에 맞게 수정
  - getFee메서드는 fee를 정상적으로 캡슐화 못함 -> getFee를 사용하는 것은 인스턴스 변수 fee의 priveate에서 public로 되는 것과 동일
### 낮은 응집도
- ReservationAgency 클래스
  - 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮음
  - 단일 책임 원칙이 필요 -> 클래스는 단 한 가지의 변경 이유만 가져야 함(여기서 책임은 변경과 관련된 더 큰 개념)

## 04. 자율적인 객체를 향해
### 캡슐화 지키기
- 객체는 스스로의 상태를 책임저야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근 해야 함
- 위의 메서드는 단순히 속성 하나의 값을 반환하거나 변경하는 접근자나 수정자가 아니라, 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드를 말함
- Rectangle 클래스
  - 내부에 너비와 높이를 조절하는 로직을 캡슐화 함 -> 변경하는 주체를 외부의 객체에서 이동
  - 자신의 크기를 Rectangle 스스로 증가시키도록 책임을 이동 시킴 -> 객체가 자기 스스로 책임 진다는 말
### 스스로 자신의 데이터를 책임지는 객체
- 상태와 행동을 객체라는 하나의 단위로 묶는 이유 -> 객체 스스로 자신의 상태를 처리 할 수 있게 하기 위해
- 객체는 단순한 데이터 제공자가 아닌 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션
- 객체를 설계할때 이 객체가 어떤 데이터를 포함 하는가?
  - 이 객체가 어떤 데이터를 포함해야 하는가?
  - 이 객체가 데이터에 대해 수행햐아 하는 오퍼레이션은 무엇인가?
    - 객체들은 스스로 책임을 지고 있음

## 05. 하지만 여전히 부족하다
### 캡슐화 위반
- DiscountCondition 클래스
  - isDiscountable 메서드
    - DiscountCondition에 포함하고 있는 DayOfWeek,LocalTime가 인스턴스 변수로 외부에 노출 됨
    - int sequence 역시 객체가 int 타입의 순번 정보를 포함하고 외부로 노출 됨
- 내부 구현을 캡슐화 실패 -> 내부 구현의 변경이 외부로 퍼저나가는 파급효과는 캡슐화가 부족 
- Moive 클래스
  - calculateAmountDiscountedFee,calculatePercentDiscountedFee,calculateNoneDiscountedFee 외부 노출
### 높은 결합도
- DiscountCondition 클래스와 Movie 클래스 사이의 결합도 높다
  - 캡슐화 원칙을 지키지 않았기 때문
### 낮은 응집도
- Screening 클래스
  - 하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 하는 것은 응집도가 낮은 것

## 06. 데이터 중심 설계의 문제점
### 캡슐화 위반
- 본질적으로 너무 이른 시기에 데이터에 관해 결정을 강요
  - 너무 이른 시기에 내부 구현에 초첨을 맞춤
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정
  - 외부의 초점이 아닌 내부의 초점으로 구현이 이미 결정되어 협력할때 억지로 인터페이스를 끼워 맞춤

## 읽고 느낀점
- 객체지향 설계는 캡슐화가 핵심이고 캡슐화를 잘하면 응집도가 높아지고 결합도가 낮아지므로 변경에 용이하다.
- 캡슐화는 변경 할 수 있는 어떠한 것이라도 감추는 것
- 내부의 초첨이 아닌 외부와 협력을 먼저 생각하고 그 바탕으로 책임을 주며 내부를 설계
